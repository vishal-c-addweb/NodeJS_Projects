/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/messagebird/lib/messagebird.js":
/*!*****************************************************!*\
  !*** ./node_modules/messagebird/lib/messagebird.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * MessageBird API methods\n *\n * @module messagebird\n */\n\nvar http = __webpack_require__(/*! https */ \"https\");\nvar querystring = __webpack_require__(/*! querystring */ \"querystring\");\nvar pkg = __webpack_require__(/*! ../package.json */ \"./node_modules/messagebird/package.json\");\nvar extend = Object.assign ? Object.assign : __webpack_require__(/*! util */ \"util\")._extend;\n\n/**\n * module.exports sets configuration\n * and returns an object with methods\n *\n * @param {String} accessKey\n * @param {Integer} timeout\n * @param {Array} features\n * @return {Object}\n */\nmodule.exports = function (accessKey, timeout, features) {\n  var config = {\n    accessKey: accessKey,\n    timeout: timeout || 5000\n  };\n\n  var CONVERSATIONS_ENDPOINT = 'conversations.messagebird.com';\n  var VOICE_ENDPOINT = 'voice.messagebird.com';\n  var IS_FIREBASE_PLUGIN_ENABLED = false;\n\n  if (features && 'indexOf' in features) {\n    if (features.indexOf('ENABLE_FIREBASE_PLUGIN') !== -1) {\n      IS_FIREBASE_PLUGIN_ENABLED = true;\n    }\n  }\n\n  /**\n   * httpRequest does the API call and process the response.\n   * requestParams.hostname is optional and defaults back to\n   * 'rest.messagebird.com'.\n   *\n   * @param {Object} requestParams\n   * @param {String} requestParams.hostname\n   * @param {String} requestParams.path\n   * @param {String} requestParams.method\n   * @param {Object} requestParams.params\n   * @param {Function} callback\n   * @return {Void}\n   */\n  function httpRequest(requestParams, callback) {\n    var options = {};\n    var complete = false;\n    var body = null;\n    var request;\n\n    if (typeof requestParams === 'function') {\n      callback = requestParams;\n      requestParams = null;\n    }\n\n    /**\n     * doCallback prevents multiple callback\n     * calls emitted by node's http module\n     *\n     * @param {Error} err\n     * @param {Mixed} res\n     * @return {Void}\n     */\n    function doCallback(err, res) {\n      if (!complete) {\n        complete = true;\n        callback(err, res || null);\n      }\n    }\n\n    function getUserAgent() {\n      if (IS_FIREBASE_PLUGIN_ENABLED) {\n        return 'MessageBird/ApiClient/FirebasePlugin';\n      }\n      return 'MessageBird/ApiClient/' + pkg.version + ' Node.js/' + process.versions.node;\n    }\n\n    // build request\n    options = {\n      hostname: requestParams.hostname || 'rest.messagebird.com',\n      path: requestParams.path,\n      method: requestParams.method,\n      headers: {\n        'Authorization': 'AccessKey ' + config.accessKey,\n        'User-Agent': getUserAgent()\n      }\n    };\n\n    if (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') {\n      body = JSON.stringify(requestParams.params);\n      options.headers['Content-Type'] = 'application/json';\n      options.headers['Content-Length'] = Buffer.byteLength(body, 'utf8');\n    } else {\n      options.path += requestParams.params ? '?' + querystring.stringify(requestParams.params) : '';\n    }\n\n    // you can override any headers you like\n    options.headers = extend(options.headers || {}, requestParams.headers || {});\n\n    request = http.request(options);\n\n    // set timeout\n    request.on('socket', function (socket) {\n      socket.setTimeout(parseInt(config.timeout, 10));\n      socket.on('timeout', function () {\n        request.abort();\n      });\n    });\n\n    // process client error\n    request.on('error', function (e) {\n      var error = new Error('request failed: ' + e.message);\n\n      if (error.message === 'ECONNRESET') {\n        error = new Error('request timeout');\n      }\n\n      error.error = e;\n      doCallback(error);\n    });\n\n    // process response\n    request.on('response', function (response) {\n      var data = [];\n      var size = 0;\n      var error = null;\n\n      response.on('data', function (ch) {\n        data.push(ch);\n        size += ch.length;\n      });\n\n      response.on('close', function () {\n        doCallback(new Error('request closed'));\n      });\n\n      response.on('end', function () {\n        data = Buffer.concat(data, size)\n          .toString()\n          .trim();\n\n        if (response.statusCode === 204) {\n          doCallback(null, true);\n          return;\n        }\n\n        try {\n          let contentDisposition = response.headers['content-disposition'];\n\n          // check if response data is downloadable so it can't be parsed to JSON\n          if (contentDisposition && contentDisposition.includes('attachment')) {\n            doCallback(error, data);\n            return;\n          }\n\n          data = JSON.parse(data);\n          if (data.errors) {\n            let clientErrors = data.errors.map(function (e) {\n              return e.description + ' (code: ' + e.code + (e.parameter ? ', parameter: ' + e.parameter : '') + ')';\n            });\n\n            error = new Error('api error(s): ' + clientErrors.join(', '));\n            error.statusCode = response.statusCode;\n            error.errors = data.errors;\n            data = null;\n          }\n        } catch (e) {\n          error = new Error('response failed');\n          error.statusCode = response.statusCode;\n          error.error = e;\n          data = null;\n        }\n\n        doCallback(error, data);\n      });\n    });\n\n    // do request\n    request.end(body);\n  }\n\n\n  // METHODS\n  return {\n    balance: {\n\n      /**\n       * Get account balance\n       *\n       * @param {Function} callback\n       * @return {void}\n       */\n      read: function (callback) {\n        httpRequest({ method: 'GET', path: '/balance' }, callback);\n      }\n    },\n\n    hlr: {\n\n      /**\n       * Get HLR report\n       *\n       * @param {Function} callback\n       * @return {void}\n       */\n      read: function (id, callback) {\n        httpRequest({ method: 'GET', path: '/hlr/' + id }, callback);\n      },\n\n      /**\n       * Send HLR network query to a number. Ref parameter is optional.\n       *\n       * @param {Number} msisdn\n       * @param {String} ref\n       * @param {Function} callback\n       * @return {void}\n       */\n      create: function (msisdn, ref, callback) {\n        var params = {\n          msisdn: msisdn,\n          reference: (typeof ref === 'function') ? null : ref\n        };\n\n        httpRequest({ method: 'POST', path: '/hlr', params: params }, callback || ref);\n      }\n    },\n\n    messages: {\n\n      /**\n       * Get a text message\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      read: function (id, callback) {\n        httpRequest({ method: 'GET', path: '/messages/' + id }, callback);\n      },\n\n      /**\n       * Lists sms messages.\n       *\n       * @param filter Filtering options.\n       * @param filter.status The status of the message.\n       * @param filter.limit The limit of messages to retrieve.\n       * @param filter.offset The number of messages to skip before selecting.\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (filter, callback) {\n        var params = {};\n\n        if (typeof callback === 'function') {\n          if (Object.prototype.hasOwnProperty.call(filter, 'limit')) {\n            params.limit = filter.limit;\n          }\n          if (Object.prototype.hasOwnProperty.call(filter, 'offset')) {\n            params.offset = filter.offset;\n          }\n          if (Object.prototype.hasOwnProperty.call(filter, 'status')) {\n            params.status = filter.status;\n          }\n        } else {\n          callback = filter;\n        }\n\n        httpRequest({ method: 'GET', path: '/messages', params: params }, callback);\n      },\n\n      /**\n       * Send a text message\n       *\n       * @param {Object} params\n       * @param {Function} callback\n       * @return {void}\n       */\n      create: function (params, callback) {\n        if (params.recipients instanceof Array) {\n          params.recipients = params.recipients.join(',');\n        }\n\n        httpRequest({ method: 'POST', path: '/messages', params: params }, callback);\n      },\n\n      /**\n       * Delete a text message\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      delete: function (id, callback) {\n        httpRequest({ method: 'DELETE', path: '/messages/' + id }, callback);\n      }\n    },\n\n    mms: {\n\n      /**\n       * Get a mms message\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      read: function (id, callback) {\n        httpRequest({ method: 'GET', path: '/mms/' + id }, callback);\n      },\n\n      /**\n       * Send a mms message\n       *\n       * @param {Object} params\n       * @param {Function} callback\n       * @return {void}\n       */\n      create: function (params, callback) {\n        if (params.recipients instanceof Array) {\n          params.recipients = params.recipients.join(',');\n        }\n        httpRequest({ method: 'POST', path: '/mms', params: params }, callback);\n      },\n\n      /**\n       * Lists mms messages. Pagination is optional. If a limit is set, an\n       * offset is also required.\n       *\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({ method: 'GET', path: '/mms', params: params }, callback);\n      },\n\n      /**\n       * Delete a mms message\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      delete: function (id, callback) {\n        httpRequest({ method: 'DELETE', path: '/mms/' + id }, callback);\n      }\n    },\n\n    voice_messages: {\n\n      /**\n       * Get a voice message\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      read: function (id, callback) {\n        httpRequest({ method: 'GET', path: '/voicemessages/' + id }, callback);\n      },\n\n      /**\n       * Lists existing voice messages. Pagination is optional. If a limit is set, an\n       * offset is also required.\n       *\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({ method: 'GET', path: '/voicemessages', params: params }, callback);\n      },\n\n      /**\n       * Send a voice message\n       *\n       * @param {Array} recipients\n       * @param {Object} params\n       * @param {Function} callback\n       * @return {void}\n       */\n      create: function (recipients, params, callback) {\n        if (recipients instanceof Object) {\n          callback = params;\n          params = recipients;\n          recipients = null;\n        }\n\n        if (recipients) {\n          params.recipients = recipients;\n        }\n\n        if (params.recipients instanceof Array) {\n          params.recipients = params.recipients.join(',');\n        }\n\n        httpRequest({ method: 'POST', path: '/voicemessages', params: params }, callback);\n      },\n\n      /**\n       * Delete a voice message\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      delete: function (id, callback) {\n        httpRequest({ method: 'DELETE', path: '/voicemessages/' + id }, callback);\n      }\n    },\n\n    verify: {\n\n      /**\n       * Get verification code details\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      read: function (id, callback) {\n        httpRequest({ method: 'GET', path: '/verify/' + id }, callback);\n      },\n\n      /**\n       * Send a verification code\n       *\n       * @param {String} recipient\n       * @param {Object} params\n       * @param {Function} callback\n       * @return {void}\n       */\n      create: function (recipient, params, callback) {\n        if (typeof params === 'function') {\n          callback = params;\n          params = {};\n        }\n\n        if (recipient instanceof Array) {\n          recipient = recipient[0];\n        }\n\n        params.recipient = recipient;\n        httpRequest({ method: 'POST', path: '/verify', params: params }, callback);\n      },\n\n      /**\n       * Send a verification code via email\n       *\n       * @param {String} from\n       * @param {String} to\n       * @param {Object} params\n       * @param {Function} callback\n       * @return {void}\n       */\n      createWithEmail: function (from, to, params, callback) {\n        if (typeof params === 'function') {\n          callback = params;\n          params = {};\n        }\n        if (!params) {\n          params = {};\n        }\n        params.type = 'email';\n        params.originator = from;\n\n        this.create(to, params, callback);\n      },\n\n      /**\n       * Delete a verification code\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      delete: function (id, callback) {\n        httpRequest({ method: 'DELETE', path: '/verify/' + id }, callback);\n      },\n\n      /**\n       * Verify a verification code\n       *\n       * @param {String} id\n       * @param {String} token\n       * @param {Function} callback\n       * @return {void}\n       */\n      verify: function (id, token, callback) {\n        var params = {\n          token: token\n        };\n\n        httpRequest({ method: 'GET', path: '/verify/' + id, params: params }, callback);\n      },\n\n      /**\n       * Get email message details\n       *\n       * @param {String} email message id\n       * @param {Function} callback\n       * @return {void}\n       */\n      getVerifyEmailMessage: function (id, callback) {\n        httpRequest({ method: 'GET', path: '/verify/messages/email/' + id }, callback);\n      }\n    },\n    lookup: {\n\n      /**\n       * Do a phonenumber lookup\n       *\n       * @param {String} phoneNumber\n       * @param {String} countryCode\n       * @param {Function} callback\n       * @return void\n       */\n      read: function (phoneNumber, countryCode, callback) {\n        var params = {};\n\n        if (typeof countryCode === 'function') {\n          callback = countryCode;\n          countryCode = null;\n        }\n\n        if (countryCode) {\n          params.countryCode = countryCode;\n        }\n\n        httpRequest({ method: 'GET', path: '/lookup/' + phoneNumber, params: params }, callback);\n      },\n\n      hlr: {\n\n        /**\n         * View an HLR lookup\n         *\n         * @param {String} phoneNumber\n         * @param {String} countryCode\n         * @param {Function} callback\n         * @return void\n         */\n        read: function (phoneNumber, countryCode, callback) {\n          var params = {};\n\n          if (typeof countryCode === 'function') {\n            callback = countryCode;\n            countryCode = null;\n          }\n\n          if (countryCode) {\n            params.countryCode = countryCode;\n          }\n\n          httpRequest({ method: 'GET', path: '/lookup/' + phoneNumber + '/hlr', params: params }, callback);\n        },\n\n        /**\n         * Request an HLR lookup\n         *\n         * @param {String} phoneNumber\n         * @param {Object} params\n         * @param {Function} callback\n         * @return void\n         */\n        create: function (phoneNumber, params, callback) {\n          if (typeof params === 'function') {\n            callback = params;\n            params = null;\n          }\n\n          httpRequest({ method: 'POST', path: '/lookup/' + phoneNumber + '/hlr', params: params }, callback);\n        }\n      }\n    },\n\n    conversations: {\n      getEndpoint: function () {\n        return CONVERSATIONS_ENDPOINT;\n      },\n\n      /**\n       * Sends a new message to a channel-specific user identifier (e.g. phone\n       * number). If an active conversation already exists for the recipient,\n       * this conversation will be resumed. If an active conversation does not\n       * exist, a new one will be created.\n       *\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      send: function (params, callback) {\n        httpRequest({\n          hostname: CONVERSATIONS_ENDPOINT,\n          method: 'POST',\n          path: '/v1/send',\n          params: params\n        }, callback);\n      },\n\n      /**\n       * Starts a new conversation from a channel-specific user identifier,\n       * such as a phone number, and sends a first message. If an active\n       * conversation already exists for the recipient, this conversation will\n       * be resumed.\n       *\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      start: function (params, callback) {\n        httpRequest({\n          hostname: CONVERSATIONS_ENDPOINT,\n          method: 'POST',\n          path: '/v1/conversations/start',\n          params: params\n        }, callback);\n      },\n\n      /**\n       * Retrieves all conversations for this account. By default,\n       * conversations are sorted by their lastReceivedDatetime field so that\n       * conversations with new messages appear first.\n       *\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({\n          hostname: CONVERSATIONS_ENDPOINT,\n          method: 'GET',\n          path: '/v1/conversations',\n          params: params\n        }, callback);\n      },\n\n      /**\n       * Retrieves a single conversation.\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return void\n       */\n      read: function (id, callback) {\n        httpRequest({\n          hostname: CONVERSATIONS_ENDPOINT,\n          method: 'GET',\n          path: '/v1/conversations/' + id\n        }, callback);\n      },\n\n      /**\n       * Update Conversation Status.\n       *\n       * @param {String} id\n       * @param {String} params\n       * @param {Function} callback\n       * @return void\n       */\n      update: function (id, params, callback) {\n        httpRequest({\n          hostname: CONVERSATIONS_ENDPOINT,\n          method: 'PATCH',\n          path: '/v1/conversations/' + id,\n          params: params\n        }, callback);\n      },\n\n      /**\n       * Adds a new message to an existing conversation and sends it to the\n       * contact that you're in conversation with.\n       *\n       * @param {String} id\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      reply: function (id, params, callback) {\n        httpRequest({\n          hostname: CONVERSATIONS_ENDPOINT,\n          method: 'POST',\n          path: '/v1/conversations/' + id + '/messages',\n          params: params\n        }, callback);\n      },\n\n      /**\n       * Lists the messages for a contact.\n       *\n       * @param {String} contactId\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      listMessages: function (id, limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({\n          hostname: CONVERSATIONS_ENDPOINT,\n          method: 'GET',\n          path: '/v1/conversations/' + id + '/messages',\n          params: params\n        }, callback);\n      },\n\n      /**\n       * View a message\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return {void}\n       */\n      readMessage: function (id, callback) {\n        httpRequest({\n          hostname: CONVERSATIONS_ENDPOINT,\n          method: 'GET',\n          path: '/v1/messages/' + id\n        }, callback);\n      },\n\n      webhooks: {\n\n        /**\n         * Creates a new webhook.\n         *\n         * @param {Object} params\n         * @param {Function} callback\n         * @return {void}\n         */\n        create: function (params, callback) {\n          httpRequest({\n            hostname: CONVERSATIONS_ENDPOINT,\n            method: 'POST',\n            path: '/v1/webhooks',\n            params: params\n          }, callback);\n        },\n\n        /**\n         * Retrieves an existing webhook by id.\n         *\n         * @param {String} id\n         * @param {Function} callback\n         * @return {void}\n         */\n        read: function (id, callback) {\n          httpRequest({\n            hostname: CONVERSATIONS_ENDPOINT,\n            method: 'GET',\n            path: '/v1/webhooks/' + id\n          }, callback);\n        },\n\n        /**\n         * Updates a webhook.\n         *\n         * @param {String} id\n         * @param {Object} params\n         * @param {Function} callback\n         * @return {void}\n         */\n        update: function (id, params, callback) {\n          httpRequest({\n            hostname: CONVERSATIONS_ENDPOINT,\n            method: 'PATCH',\n            path: '/v1/webhooks/' + id,\n            params: params\n          }, callback);\n        },\n\n        /**\n         * Retrieves a list of webhooks.\n         *\n         * @param {Number} perPage\n         * @param {Number} currentPage\n         * @param {Function} callback\n         * @return void\n         */\n        list: function (limit, offset, callback) {\n          var params = null;\n\n          if (typeof callback === 'function') {\n            params = {\n              limit: limit,\n              offset: offset\n            };\n          } else {\n            callback = limit;\n          }\n\n          httpRequest({\n            hostname: CONVERSATIONS_ENDPOINT,\n            method: 'GET',\n            path: '/v1/webhooks',\n            params: params\n          }, callback);\n        },\n\n        /**\n         * Deletes webhook\n         *\n         * @param {String} id\n         * @param {Function} callback\n         * @return {void}\n         */\n        delete: function (id, callback) {\n          httpRequest({\n            hostname: CONVERSATIONS_ENDPOINT,\n            method: 'DELETE',\n            path: '/v1/webhooks/' + id\n          }, callback);\n        }\n      }\n    },\n\n    voice: {\n      webhooks: {\n\n        /**\n         * Creates a new webhook.\n         *\n         * @param {Object} params\n         * @param {Function} callback\n         * @return {void}\n         */\n        create: function (params, callback) {\n          httpRequest({\n            hostname: VOICE_ENDPOINT,\n            method: 'POST',\n            path: '/webhooks',\n            params: params\n          }, callback);\n        },\n\n        /**\n         * Retrieves an existing webhook by id.\n         *\n         * @param {String} id\n         * @param {Function} callback\n         * @return {void}\n         */\n        read: function (id, callback) {\n          httpRequest({\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: '/webhooks/' + id\n          }, callback);\n        },\n\n        /**\n         * Updates a webhook.\n         *\n         * @param {String} id\n         * @param {Object} params\n         * @param {Function} callback\n         * @return {void}\n         */\n        update: function (id, params, callback) {\n          httpRequest({\n            hostname: VOICE_ENDPOINT,\n            method: 'PUT',\n            path: '/webhooks/' + id,\n            params: params\n          }, callback);\n        },\n\n        /**\n         * Retrieves a list of webhooks.\n         *\n         * @param {Number} perPage\n         * @param {Number} currentPage\n         * @param {Function} callback\n         * @return void\n         */\n        list: function (perPage, currentPage, callback) {\n          var params = null;\n\n          if (typeof callback === 'function') {\n            params = {\n              perPage: perPage,\n              currentPage: currentPage\n            };\n          } else {\n            callback = perPage;\n          }\n\n          httpRequest({\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: '/webhooks',\n            params: params\n          }, callback);\n        },\n\n        /**\n         * Deletes webhook\n         *\n         * @param {String} id\n         * @param {Function} callback\n         * @return {void}\n         */\n        delete: function (id, callback) {\n          httpRequest({\n            hostname: VOICE_ENDPOINT,\n            method: 'DELETE',\n            path: '/webhooks/' + id\n          }, callback);\n        }\n      }\n    },\n\n    contacts: {\n\n      /**\n       * Create a new contact. Params is optional.\n       *\n       * @param {String} phoneNumber\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      create: function (phoneNumber, params, callback) {\n        if (typeof params === 'function') {\n          callback = params;\n          params = {};\n        }\n\n        params.msisdn = phoneNumber;\n\n        httpRequest({ method: 'POST', path: '/contacts', params: params }, callback);\n      },\n\n      /**\n       * Deletes an existing contact. The callback is invoked with an error if\n       * applicable, but the data will never contain anything meaningful as the\n       * API returns an empty response for successful deletes.\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return void\n       */\n      delete: function (id, callback) {\n        httpRequest({ method: 'DELETE', path: '/contacts/' + id }, callback);\n      },\n\n      /**\n       * Lists existing contacts. Pagination is optional. If a limit is set, an\n       * offset is also required.\n       *\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({ method: 'GET', path: '/contacts', params: params }, callback);\n      },\n\n      /**\n       * View an existing contact.\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return void\n       */\n      read: function (id, callback) {\n        httpRequest({ method: 'GET', path: '/contacts/' + id }, callback);\n      },\n\n      /**\n       * Updates an existing contact. Params is optional.\n       *\n       * @param {String} id\n       * @param {String} name\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      update: function (id, params, callback) {\n        httpRequest({ method: 'PATCH', path: '/contacts/' + id, params: params }, callback);\n      },\n\n      /**\n       * Lists the groups a contact is part of.\n       *\n       * @param {String} contactId\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      listGroups: function (contactId, limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({ method: 'GET', path: '/contacts/' + contactId + '/groups', params: params }, callback);\n      },\n\n      /**\n       * Lists the messages for a contact.\n       *\n       * @param {String} contactId\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      listMessages: function (contactId, limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({ method: 'GET', path: '/contacts/' + contactId + '/messages', params: params }, callback);\n      }\n\n    },\n\n    callflows: {\n\n      /**\n       * Lists existing call flows.\n       * @param {Number} page\n       * @param {Number} perpage\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (page, perpage, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            page: page,\n            perPage: perpage\n          };\n        } else {\n          callback = page;\n        }\n\n        httpRequest({\n          hostname: VOICE_ENDPOINT,\n          method: 'GET',\n          path: '/call-flows',\n          params: params\n        },\n        callback);\n      },\n\n      /**\n       * Creates a new call flow, params are mandatory.\n       *\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      create: function (params, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'POST',\n            path: '/call-flows',\n            params: params\n          },\n          callback);\n      },\n\n      /**\n       * Get a call flow\n       *\n       * @param {String} flowId\n       * @param {Function} callback\n       * @return {void}\n       */\n      read: function (flowId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: '/call-flows/' + flowId\n          },\n          callback\n        );\n      },\n\n      /**\n       * Deletes an existing call flow. The callback is invoked with an error if\n       * applicable, but the data will never contain anything meaningful as the\n       * API returns an empty response for successful deletes.\n       *\n       * @param {String} flowId\n       * @param {Function} callback\n       * @return void\n       */\n      delete: function (flowId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'DELETE',\n            path: '/call-flows/' + flowId\n          },\n          callback\n        );\n      },\n\n      /**\n       * Updates an existing call flow. Params are required.\n       *\n       * @param {String} flowId\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      update: function (flowId, params, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'PUT',\n            path: '/call-flows/' + flowId,\n            params: params\n          },\n          callback\n        );\n      }\n    },\n    groups: {\n\n      /**\n       * Creates a new group. Params is optional.\n       *\n       * @param {String} name\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      create: function (name, params, callback) {\n        if (typeof params === 'function') {\n          callback = params;\n          params = {};\n        }\n\n        params.name = name;\n\n        httpRequest({ method: 'POST', path: '/groups', params: params }, callback);\n      },\n\n      /**\n       * Deletes an existing group. The callback is invoked with an error if\n       * applicable, but the data will never contain anything meaningful as the\n       * API returns an empty response for successful deletes.\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return void\n       */\n      delete: function (id, callback) {\n        httpRequest({ method: 'DELETE', path: '/groups/' + id }, callback);\n      },\n\n      /**\n       * Lists existing groups. Pagination is optional. If a limit is set, an\n       * offset is also required.\n       *\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({ method: 'GET', path: '/groups', params: params }, callback);\n      },\n\n      /**\n       * View an existing group.\n       *\n       * @param {String} id\n       * @param {Function} callback\n       * @return void\n       */\n      read: function (id, callback) {\n        httpRequest({ method: 'GET', path: '/groups/' + id }, callback);\n      },\n\n      /**\n       * Updates an existing contact. Parmas is optional.\n       *\n       * @param {String} id\n       * @param {String} name\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      update: function (id, name, params, callback) {\n        if (typeof params === 'function') {\n          callback = params;\n          params = {};\n        }\n\n        params.name = name;\n\n        httpRequest({ method: 'PATCH', path: '/groups/' + id, params: params }, callback);\n      },\n\n      /**\n       * Adds anywhere from 1 to 50 contacts to a group.\n       *\n       * @param {String} groupId\n       * @param {String[]} contactIds\n       * @param {Function} callback\n       * @return void\n       */\n      addContacts: function (groupId, contactIds, callback) {\n        const params = {\n          groupId,\n          ids: contactIds\n        }\n\n        httpRequest({ method: 'PUT', path: '/groups/' + groupId + '/contacts', params }, callback);\n      },\n\n      /**\n       * Lists the contacts that are part of a group.\n       *\n       * @param {String} groupId\n       * @param {Number} limit\n       * @param {Number} offset\n       * @param {Function} callback\n       * @return void\n       */\n      listContacts: function (groupId, limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit: limit,\n            offset: offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest({ method: 'GET', path: '/groups/' + groupId + '/contacts', params: params }, callback);\n      },\n\n      /**\n       * Removes a single contact from a group.\n       *\n       * @param {String} groupId\n       * @param {String} contactId\n       * @param {Function} callback\n       * @return void\n       */\n      removeContact: function (groupId, contactId, callback) {\n        httpRequest({ method: 'DELETE', path: '/groups/' + groupId + '/contacts/' + contactId }, callback);\n      }\n\n    },\n    calls: {\n\n      /**\n       * Create a call.\n       *\n       * @param {Object} params\n       * @param {Function} callback\n       * @return void\n       */\n      create: function (params, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'POST',\n            path: '/calls',\n            params\n          },\n          callback\n        );\n      },\n\n      /**\n       * List calls.\n       *\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: '/calls'\n          },\n          callback\n        );\n      },\n\n      /**\n       * Read a call.\n       *\n       * @param {String} callId\n       * @param {Function} callback\n       * @return void\n       */\n      read: function (callId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: `/calls/${callId}`\n          },\n          callback\n        );\n      },\n\n      /**\n       * Delete a call.\n       *\n       * @param {String} callId\n       * @param {Function} callback\n       * @return void\n       */\n      delete: function (callId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'DELETE',\n            path: `/calls/${callId}`\n          },\n          callback\n        );\n      }\n    },\n    recordings: {\n\n      /**\n       * View an existing recording.\n       *\n       * @param {String} callId\n       * @param {String} legId\n       * @param {String} recordingId\n       * @param {Function} callback\n       * @return void\n       */\n      read: function (callId, legId, recordingId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: `/calls/${callId}/legs/${legId}/recordings/${recordingId}`\n          },\n          callback\n        );\n      },\n\n      /**\n       * List recordings.\n       *\n       * @param {String} callId\n       * @param {String} legId\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (callId, legId, limit, offset, callback) {\n        var params = null;\n\n        if (typeof callback === 'function') {\n          params = {\n            limit,\n            offset\n          };\n        } else {\n          callback = limit;\n        }\n\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: `/calls/${callId}/legs/${legId}/recordings`,\n            params\n          },\n          callback\n        );\n      },\n\n      /**\n       * Delete recordings.\n       *\n       * @param {String} callId\n       * @param {String} legId\n       * @param {String} recId\n       * @param {Function} callback\n       * @return void\n       */\n\n      delete: function (callId, legId, recId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'DELETE',\n            path: `/calls/${callId}/legs/${legId}/recordings/${recId}`\n          },\n          callback\n        );\n      },\n\n\n      /**\n       * Download an existing recording.\n       *\n       * @param {String} callId\n       * @param {String} legId\n       * @param {String} recordingId\n       * @param {Function} callback\n       * @return void\n       */\n      download: function (callId, legId, recordingId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: `/calls/${callId}/legs/${legId}/recordings/${recordingId}.wav`\n          },\n          callback\n        );\n      }\n    },\n    transcriptions: {\n\n      /**\n       * Creates a new transcription.\n       * @param {String} callId\n       * @param {String} legId\n       * @param {String} recordingId\n       * @param {String} language\n       * @param {Function} callback\n       * @return void\n       */\n      create: function (callId, legId, recordingId, language, callback) {\n        var params = {\n          language: language\n        };\n\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'POST',\n            path: `/calls/${callId}/legs/${legId}/recordings/${recordingId}/transcriptions`,\n            params: params\n          },\n          callback\n        );\n      },\n\n      /**\n       * List transcriptions.\n       * @param {String} callId\n       * @param {String} legId\n       * @param {String} recordingId\n       * @param {Function} callback\n       * @return void\n       */\n      list: function (callId, legId, recordingId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: `/calls/${callId}/legs/${legId}/recordings/${recordingId}/transcriptions`\n          },\n          callback\n        );\n      },\n\n      /**\n       * View an existing transcription.\n       *\n       * @param {String} callId\n       * @param {String} legId\n       * @param {String} recordingId\n       * @param {String} language\n       * @param {Function} callback\n       * @return void\n       */\n      read: function (callId, legId, recordingId, transcriptionId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: `/calls/${callId}/legs/${legId}/recordings/${recordingId}/transcriptions/${transcriptionId}`\n          },\n          callback\n        );\n      },\n\n      /**\n       * Downloads an existing transcription.\n       * @param {String} callId\n       * @param {String} legId\n       * @param {String} recordingId\n       * @param {String} transcriptionId\n       * @param {Function} callback\n       * @return void\n       */\n      download: function (callId, legId, recordingId, transcriptionId, callback) {\n        httpRequest(\n          {\n            hostname: VOICE_ENDPOINT,\n            method: 'GET',\n            path: `/calls/${callId}/legs/${legId}/recordings/${recordingId}/transcriptions/${transcriptionId}.txt`\n          },\n          callback\n        );\n      }\n    }\n  };\n};\n\n\n//# sourceURL=webpack://practice/./node_modules/messagebird/lib/messagebird.js?");

/***/ }),

/***/ "./node_modules/otp-generator/index.js":
/*!*********************************************!*\
  !*** ./node_modules/otp-generator/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Generate password from allowed word\n */\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\")\n\nconst digits = '0123456789'\nconst alphabets = 'abcdefghijklmnopqrstuvwxyz'\nconst upperCase = alphabets.toUpperCase()\nconst specialChars = '#!&@'\n\nmodule.exports = {\n  /**\n   * Generate OTP of the length\n   * @param  {number} length length of password.\n   * @param  {object} options\n   * @param  {boolean} options.digits Default: `true` true value includes digits in OTP\n   * @param  {boolean} options.alphabets Default: `true` true value includes alphabets in OTP\n   * @param  {boolean} options.upperCase Default: `true` true value includes upperCase in OTP\n   * @param  {boolean} options.specialChars Default: `true` true value includes specialChars in OTP\n   */\n  generate: function (length, options) {\n    length = length || 10\n    const generateOptions = options || {}\n\n    generateOptions.digits = Object.prototype.hasOwnProperty.call(generateOptions, 'digits') ? options.digits : true\n    generateOptions.alphabets = Object.prototype.hasOwnProperty.call(generateOptions, 'alphabets') ? options.alphabets : true\n    generateOptions.upperCase = Object.prototype.hasOwnProperty.call(generateOptions, 'upperCase') ? options.upperCase : true\n    generateOptions.specialChars = Object.prototype.hasOwnProperty.call(generateOptions, 'specialChars') ? options.specialChars : true\n\n    const allowsChars = ((generateOptions.digits || '') && digits) +\n      ((generateOptions.alphabets || '') && alphabets) +\n      ((generateOptions.upperCase || '') && upperCase) +\n      ((generateOptions.specialChars || '') && specialChars)\n    let password = ''\n    while (password.length < length) {\n      const charIndex = crypto.randomInt(0, allowsChars.length)\n      password += allowsChars[charIndex]\n    }\n    return password\n  }\n\n}\n\n\n//# sourceURL=webpack://practice/./node_modules/otp-generator/index.js?");

/***/ }),

/***/ "./config/dbconnection.ts":
/*!********************************!*\
  !*** ./config/dbconnection.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst config_1 = __importDefault(__webpack_require__(/*! config */ \"config\"));\nconst mongoose_1 = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst connectDB = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const mongoURI = config_1.default.get(\"mongoURI\");\n        const options = {\n            useNewUrlParser: true,\n            useCreateIndex: true,\n            useFindAndModify: false,\n            useUnifiedTopology: true,\n        };\n        yield (0, mongoose_1.connect)(mongoURI, options);\n        console.log(\"MongoDB Connected...\");\n    }\n    catch (err) {\n        console.error(err.message);\n        // Exit process with failure\n        process.exit(1);\n    }\n});\nexports[\"default\"] = connectDB;\n\n\n//# sourceURL=webpack://practice/./config/dbconnection.ts?");

/***/ }),

/***/ "./src/controller/sendOtpController.ts":
/*!*********************************************!*\
  !*** ./src/controller/sendOtpController.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst otpGenerator = __webpack_require__(/*! otp-generator */ \"./node_modules/otp-generator/index.js\");\nconst Otp_1 = __importDefault(__webpack_require__(/*! ../model/Otp */ \"./src/model/Otp.ts\"));\nconst sendOtpController = {\n    /**\n     * Request a mobile & password from User and login or register the user and return jwt token.\n     * @param req\n     * @param res\n     * @returns {*}\n     */\n    loginRegister: function loginRegister(req, res) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var messagebird = __webpack_require__(/*! messagebird */ \"./node_modules/messagebird/lib/messagebird.js\")('9pRSR4ladJjJHRGiV5Of35xW5');\n            var otp = otpGenerator.generate(6, { upperCase: false, specialChars: false, alphabets: false, digits: true });\n            var params = {\n                'originator': 'MessageBird',\n                'recipients': [\n                    req.body.mobile\n                ],\n                'body': 'Otp message for Cowid-19 your OTP is ' + otp\n            };\n            messagebird.messages.create(params, function (err, response) {\n                if (err) {\n                    console.log(err);\n                    return res.json(err);\n                }\n                const otpFields = {\n                    otp: otp,\n                    expiration_time: new Date(new Date().getTime() + 3 * 60000),\n                    verified: false\n                };\n                otp = new Otp_1.default(otpFields);\n                otp.save();\n                return res.json(response);\n            });\n        });\n    },\n    /**\n     * Request a jwt token from User and return user data.\n     * @param req\n     * @param res\n     * @returns {*}\n     */\n    userData: function userData(req, res) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var messagebird = __webpack_require__(/*! messagebird */ \"./node_modules/messagebird/lib/messagebird.js\")('9pRSR4ladJjJHRGiV5Of35xW5');\n            messagebird.messages.read('b265884fb5164e6eacdb1736f27a4350', function (err, response) {\n                if (err) {\n                    return console.log(err);\n                }\n                console.log(response);\n            });\n        });\n    },\n    verify: function verify(req, res) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var otp = req.body.otp;\n            var notExpire = yield Otp_1.default.findOne({ otp: otp, verified: false, expiration_time: { $gt: new Date() } });\n            if (notExpire) {\n                res.status(200).json(\"your otp verified successfully\");\n                yield Otp_1.default.updateOne({ otp: otp }, { verified: true });\n            }\n            else {\n                res.status(403).json(\"your otp expired\");\n            }\n        });\n    }\n};\nexports[\"default\"] = sendOtpController;\n\n\n//# sourceURL=webpack://practice/./src/controller/sendOtpController.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dbconnection_1 = __importDefault(__webpack_require__(/*! ../config/dbconnection */ \"./config/dbconnection.ts\"));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ \"express\"));\nconst sendOtp_1 = __importDefault(__webpack_require__(/*! ./routes/sendOtp */ \"./src/routes/sendOtp.ts\"));\nconst bodyParser = __webpack_require__(/*! body-parser */ \"body-parser\");\nconst app = (0, express_1.default)();\n//connect to db\n(0, dbconnection_1.default)();\n// Express configuration\napp.set(\"port\", process.env.PORT || 3000);\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\napp.get(\"/\", (_req, res) => {\n    res.send(\"API Running\");\n});\napp.use('/api', sendOtp_1.default);\nconst port = app.get(\"port\");\nconst server = app.listen(port, () => console.log(`Server started on port ${port}`));\nexports[\"default\"] = server;\n\n\n//# sourceURL=webpack://practice/./src/index.ts?");

/***/ }),

/***/ "./src/model/Otp.ts":
/*!**************************!*\
  !*** ./src/model/Otp.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mongoose_1 = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ \"mongoose\"));\nconst otpSchema = new mongoose_1.Schema({\n    otp: { type: Number },\n    expiration_time: { type: Date },\n    verified: { type: Boolean }\n});\nconst Otp = mongoose_2.default.model(\"Otp\", otpSchema);\nexports[\"default\"] = Otp;\n\n\n//# sourceURL=webpack://practice/./src/model/Otp.ts?");

/***/ }),

/***/ "./src/routes/sendOtp.ts":
/*!*******************************!*\
  !*** ./src/routes/sendOtp.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst sendOtpController_1 = __importDefault(__webpack_require__(/*! ../controller/sendOtpController */ \"./src/controller/sendOtpController.ts\"));\nconst router = (0, express_1.Router)();\n// @route   POST user\n// @desc    Give Mobile number, returns the token upon successful registration or login.\n// @access  Public\nrouter.post(\"/sendotp\", sendOtpController_1.default.loginRegister);\n// @route   GET user\n// @access  Private\nrouter.get(\"/sendotp\", sendOtpController_1.default.userData);\n// @route   POST user\n// @desc    Give Mobile number, returns the token upon successful registration or login.\n// @access  Public\nrouter.post(\"/verify\", sendOtpController_1.default.verify);\nexports[\"default\"] = router;\n\n\n//# sourceURL=webpack://practice/./src/routes/sendOtp.ts?");

/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("body-parser");

/***/ }),

/***/ "config":
/*!*************************!*\
  !*** external "config" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("config");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("express");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("mongoose");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "./node_modules/messagebird/package.json":
/*!***********************************************!*\
  !*** ./node_modules/messagebird/package.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"messagebird\",\"version\":\"3.7.1\",\"description\":\"A node.js wrapper for the MessageBird REST API\",\"main\":\"lib/messagebird.js\",\"types\":\"types\",\"engines\":{\"node\":\">=10.0.0\"},\"scripts\":{\"test\":\"node lib/test.js\",\"dtslint\":\"dtslint types\"},\"repository\":{\"type\":\"git\",\"url\":\"git+ssh://git@github.com/messagebird/messagebird-nodejs.git\"},\"keywords\":[\"messagebird\",\"sms\",\"tts\",\"hlr\",\"2fa\",\"otp\",\"voice\"],\"author\":\"MessageBird <support@messagebird.com> (https://www.messagebird.com/)\",\"contributors\":[\"Franklin van de Meent <fr@nkl.in> (https://frankl.in/)\"],\"license\":\"BSD-2-Clause\",\"homepage\":\"https://github.com/messagebird/messagebird-nodejs\",\"dependencies\":{\"jose\":\"^3.14\",\"safe-buffer\":\"^5.2.1\",\"scmp\":\"^2.1.0\"},\"devDependencies\":{\"dtslint\":\"^4.0.9\",\"nock\":\"^11.3.2\",\"typescript\":\"^4.2.4\"}}');\n\n//# sourceURL=webpack://practice/./node_modules/messagebird/package.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;